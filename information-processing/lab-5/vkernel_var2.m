function p_=vkernel_var2(x,XN,h_N,kl_kernel)
%Функция для отображения ядра и получения оценки 
%плотности распределения вероятностей методом Парзена
%x-массив векторов (точек), для которых определяется плотность
%XN-входная обучающая выборка данных
%h_N- параметр, определяющий размер области локализации ядра (оконной функции)
%kl_kernel-ключ для определения вида используемого ядра
%kl_kernel=11 - гауссовская функция c использованием диагональной матрицы;
%kl_kernel=12 - гауссовская функция c использованием матрицы ковариации;
%kl_kernel=2 - показательная функция;    
%kl_kernel=3 - оконная прямоугольная функция;
%kl_kernel=4 - оконная треугольная функция;
% НОВЫЕ КЛЮЧИ
%kl_kernel=5 - оконная функция (вар.2.а)
%kl_kernel=6 - оконная функция (вар.2.б)

[n1,mx]=size(x);%размерность пространства и число точек, для которых проводится оценка
[n2,N]=size(XN);%размерность пространства и объем обучающей выборки 
if n1==n2, n=n1;
    p_=zeros(1,mx); C=eye(n,n); C_=C;
    if kl_kernel==12 && N>1, %оценка выборочной матрицы ковариаций 
        C=zeros(n,n); m_=mean(XN')';
        for i=1:N,
             C=C+(XN(:,i)-m_)*(XN(:,i)-m_)';
        end;
        C=C/(N-1); C_=C^-1;
    end;
    %Вычисление значений функций ядра с центрами XN(:,1:N) в точках x(:,1:mx)
    %При N=1 получаем единичную функцию ядра c с центром XN(:,1)
    fit=zeros(N,mx); 
    for i=1:N,
        p_k=zeros(n,mx); mx_i=repmat(XN(:,i),[1,mx]);
        switch kl_kernel,
            case 11,
                ro=sum((x-mx_i).^2,1); 
                fit(i,:)=exp(-ro/(2*h_N^2))/((2*pi)^(n/2)*(h_N^n));
            case 12,
                ro=sum((C_*(x-mx_i)).*(x-mx_i),1);
                fit(i,:)=exp(-ro/(2*h_N^2))*((2*pi)^(-n/2)*(h_N^-n)*(det(C)^-0.5));
            case 2,
                ro=abs(x-mx_i)/h_N; 
                fit(i,:)=prod(exp(-ro),1)/(2*h_N^n); 
            case 3,
                ro=abs(x-mx_i)/h_N; 
                for k=1:n, 
                    ind=logical(ro(k,:)<1); p_k(k,ind)=1/2;
                end;
                fit(i,:)=prod(p_k,1)/h_N^n;
            case 4,
                ro=abs(x-mx_i)/h_N; 
                for k=1:n, 
                   ind=logical(ro(k,:)<1); p_k(k,ind)=(1-ro(k,ind));
                end;
                fit(i,:)=prod(p_k,1)/h_N^n;
            % ЗДЕСЬ добавляются новые кейсы
            case 5, % вар. 2.а)
                ro=(x-mx_i)/h_N;
                fit(i,:)=1/(pi*h_N)*1./(1+ro.^2);   % точечки перед делением и возведением в квадрат!
            case 6, % вар. 2.б)
                ro=(x-mx_i)/(2*h_N); 
                fit(i,:)=1/(2*pi*h_N)*(sin(ro)./ro).^2; 
        end; %kl_kernel
    end;%i=1:N
    %Вычисление оценки плотности распределения вероятностей
    if N>1, p_=sum(fit)/N; else p_=fit; end;
else %n1=~n2
    error('размерности данных (n1 и n2) не совпадают');
end;
