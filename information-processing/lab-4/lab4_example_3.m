% Файл pr54_rec_bin. Синтез и анализ алгоритмов распознавания образов по дискретным 
% признакам (на примере распознавания бинарных изображений)

% ПРИМЕР ДЛЯ ТРЁХ КЛАССОВ С ВЫВОДОМ МАТРИЦ ОШИБОК

clear all;
close all;
%% 1. Задание исходных данных
n = 35; % количество признаков (исходя из размера изображений)
M = 3; % ЗДЕСЬ М меняется на 3
s = zeros(n, M); % количество классов и эталонные описания
% 1.1. Задание эталонов классов (ЗДЕСЬ добавляется описание третей буквы)
letterK =  [1 0 0 0 1 ...   
            1 0 0 1 0 ...
            1 0 1 0 0 ...
            1 1 0 0 0 ...
            1 0 1 0 0 ...
            1 0 0 1 0 ...
            1 0 0 0 1 ]';
letterS =  [0 1 1 1 0 ...
            1 0 0 0 1 ...
            1 0 0 0 0 ...
            0 1 1 1 0 ...
            0 0 0 0 1 ...
            1 0 0 0 1 ...
            0 1 1 1 0 ]';
letterM =  [1 0 0 0 1 ...   % Добавляется третья буква
            1 1 0 1 1 ...
            1 0 1 0 1 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ]';        
s(:, 1) = letterK; 
s(:, 2) = letterS;
s(:, 3) = letterM; % Добавляется третья буква
% 1.2. Задание параметров эксперимента (ЗДЕСЬ добавляется третье значение в pw)
pw = [0.5 0.5 0.5]; %априорные вероятности гипотез
np = sum(pw);
pw = pw / np; % исключение некорректного задания априорных вероятностей
N = 20;  % количество шагов изменения варьируемого параметра - pi
K = 1000; % количество реализаций
pi = zeros(1, N); % массив вероятностей искажения символа

% ЗДЕСЬ Удаляется пункт 1.3.

% 1.4. Матрицы ошибок (ЗДЕСЬ добавляется теоретическая матрица ошибок)
Pc_ = zeros(M); % экспериментальная матрица вероятностей ошибок
Pt = zeros(M); % МАТРИЦЫ теперь двумерные

% ЗДЕСЬ убирается объявление цикла (тело цикла остаётся)
% Цикл по значениям вероятности искажения элементов символов
% for t = 1 : N    
%     pi(t) = (1 / N) * (t - 1);
%     pI = pi(t); % вероятность искажения элемента (пикселя)
pI = 0.25; % ЗДЕСЬ задается фиксированное значение вероятности искажения (pI)

% 2.Синтез решающего правила и расчет теоретических вероятностей ошибок
if pI == 0
    pI = 0.0001;
end % регуляризация разделяющей функции
if pI == 0.5
    pI = 0.4999;
end
pI_ = 1 - pI;
s_ = 1 - s; % получение инвертированных изображений
G1 = zeros(1, n);
G2 = zeros(1, n); 

% ДОБАВЛЯЕТСЯ двойной цикл и пункты 1.1. - 1.3. уходят внутрь него
% В п.1.1-1.2 индексы при s() и при pw() равные 1 меняются на ii,
% равные 2 меняются на jj
% П. 1.1. и 1.2. надо скопировать в п.3.2.
% Попарное сравнение классов
for ii = 1 : M - 1
    for jj = ii + 1 : M
        % 2.1. Вычисление порога принятия решений 
        ns = sum(abs(s(:, ii) - s(:, jj))); % общее количество несовпадающих элементов
        l0_ = log(pw(jj) / pw(ii)); % порог принятия решения
        L0  = log(pw(jj) / pw(ii)) / (2 * log(pI_) - 2 * log(pI)) + ns / 2; 
        L0r = floor(L0);
        
        % 2.2.Вычисление коэффициентов разделяющей функции (этот пункт отсюда можно убрать)
        for k = 1 : n
           G1(1, k) = log((s(k, ii) * pI_ + s_(k, ii) * pI) / (s(k, jj) * pI_ + s_(k, jj) * pI));
           G2(1, k) = log((s(k, ii) * pI + s_(k, ii) * pI_) / (s(k, jj) * pI + s_(k, jj) * pI_));
        end
        
        % 2.3. Определение вероятностей перепутывания
        % Здесь вместо p12th(t) будет Pt(ii,jj), вместо p21th(t) - Pt(jj,ii)
        if pI < 0.5 % расчет вероятностей ошибок
            Pt(ii,jj) = binocdf(L0r, ns, 1-pI);
            Pt(jj,ii) = 1 - binocdf(L0r, ns, pI);
        else
            Pt(ii,jj) = 1 - binocdf(L0r, ns, 1 - pI);
            Pt(jj,ii) = binocdf(L0r, ns, pI);
        end
    end
end
% ЗДЕСЬ добавляется строчка с вычислением диагональных элементов теор. матрицы ошибок
% Вычисление вероятностей правильного распознавания (диагональные элементы)
Pt = Pt + diag(ones(3, 1) - sum(Pt, 2));

%% 3. Тестирование алгоритма методом статистических испытаний
for kk = 1 : K % цикл по числу реализаций
    for i = 1 : M % цикл по классам
        % 3.1. Моделирование искажения
        x = s(:, i);
        r = rand(n, 1); 
        ir = find(r < pI);
        x(ir) = 1 - x(ir); % искажение элементов – инверсия в случайных точках
        x_ = 1 - x;
        
        % 3.2. Классификация искаженного образа (попарное сравнение классов)
        % ЗДЕСЬ добавляется инициализация массива для хранения
        % результатов попарных сравнений классов; п.3.2 помещается
        % внутрь двойного цикла вместе с п.2.1 и 2.2.
        iais = [];  % результаты попарных сравнений (индексы классов)
        for ii = 1 : M - 1
            for jj = ii + 1 : M
                % Копия 2.1. Вычисление порога принятия решений 
                ns = sum(abs(s(:, ii) - s(:, jj))); % общее количество несовпадающих элементов
                l0_ = log(pw(jj) / pw(ii)); % порог принятия решения
                L0  = log(pw(jj) / pw(ii)) / (2 * log(pI_) - 2 * log(pI)) + ns / 2;
                L0r = floor(L0);

                % Копия 2.2.Вычисление коэффициентов разделяющей функции
                for k = 1 : n % вычисление коэффициентов разделяющей функции
                   G1(1, k) = log((s(k, ii) * pI_ + s_(k, ii) * pI) / (s(k, jj) * pI_ + s_(k, jj) * pI));
                   G2(1, k) = log((s(k, ii) * pI + s_(k, ii) * pI_) / (s(k, jj) * pI + s_(k, jj) * pI_));
                end
                
                % ЗДЕСЬ вместо индексов классов будут ii и jj
                % 3.2. Классификация искаженного образа
                u = G1 * x + G2 * x_ - l0_; % вычисление значения разделяющих функций
                if u > 0
                    iai = ii;
                else
                    iai = jj;
                end
                
                % ЗДЕСЬ Запоминаем результат попарного сравнения
                iais = [iais, iai];
            end
        end
        % ЗДЕСЬ выбираем индекс класса, за который проголосовали
        % большинство парных классификаторов
        id = mode(iais);   % самый часто повторяющийся индекс
        
        % 3.3. Фиксация результата распознавания
        Pc_(i, id) = Pc_(i, id) + 1; % фиксация результата распознавания            
    end
end
Pc_ = Pc_ / K;  % Здесь можно убрать индексы при Pc_
% end;  % убирается end относящийся к циклу по t
% ДОБАВЛЯЕТСЯ вывод матриц
disp('Теоретическая матрица ошибок')
disp(Pt)
disp('Экспериментальная матрица ошибок')
disp(Pc_)