% Файл pr54_rec_bin. Синтез и анализ алгоритмов распознавания образов по дискретным 
% признакам (на примере распознавания бинарных изображений)

% ПРИМЕР ДЛЯ ИЗМЕНЕНИЯ ФОРМУЛЫ РАЗДЕЛЯЮЩЕЙ ФУНКЦИИ

clear all;
close all;
%% 1. Задание исходных данных
n = 35; % количество признаков (исходя из размера изображений)
M = 2;
s = zeros(n, M); % количество классов и эталонные описания
% 1.1. Задание эталонов классов
letterP =  [1 1 1 1 0 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ...
            1 1 1 1 0 ...
            1 0 0 0 0 ...
            1 0 0 0 0 ...
            1 0 0 0 0 ]';
letterM =  [1 0 0 0 1 ...
            1 1 0 1 1 ...
            1 0 1 0 1 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ...
            1 0 0 0 1 ]';
% буква P и буква M
s(:, 1) = letterP; 
s(:, 2) = letterM;
% 1.2. Задание параметров эксперимента
pw = [0.7, 0.3]; % априорные вероятности гипотез
np = sum(pw);
pw = pw / np; % исключение некорректного задания априорных вероятностей
N = 20; % количество шагов изменения варьируемого параметра - pi
K = 1000; % количество реализаций
pi = zeros(1, N); % массив вероятностей искажения символа
% 1.3. Массивы теор. и эксп. ошибок первого и второго рода
p12th = pi; 
p21th = pi;
p12ex = pi;
p21ex = pi;
% 1.4. Матрица ошибок
Pc_ = zeros(M, M, N); % экспериментальная матрица вероятностей ошибок

% Цикл по значениям вероятности искажения элементов символов
for t = 1 : N
    pi(t) = (1 / N) * (t - 1);
    pI = pi(t); % вероятность искажения элемента (пикселя)
    
	% 2.Синтез решающего правила и расчет теоретических вероятностей ошибок
    if pI == 0
        pI = 0.0001;
    end % регуляризация разделяющей функции
    if pI == 0.5
        pI = 0.4999;
    end
    pI_ = 1 - pI;
    s_ = 1 - s; % получение инвертированных изображений
    G1 = zeros(1, n);
    G2 = zeros(1, n);
    
    % 2.1. Вычисление порога принятия решений 
    ns = sum(abs(s(:, 1) - s(:, 2))); % общее количество несовпадающих элементов
    l0_ = log(pw(2) / pw(1)); % порог принятия решения
    L0  = log(pw(2) / pw(1)) / (2 * log(pI_) - 2 * log(pI)) + ns / 2; 
	L0r = floor(L0);
    
    % 2.2. ЗДЕСЬ ВМЕСТО вычисления коэффициентов разделяющей функции,
    % создаем маски различающихся элементов
    mask10 = (s(:, 1)==1)&(s(:, 2)==0);   % маски несовпадающих элементов
    mask01 = (s(:, 1)==0)&(s(:, 2)==1);
    
    % 2.3. Определение вероятностей перепутывания 
    if pI < 0.5 % расчет вероятностей ошибок 
        p12th(t) = binocdf(L0r, ns, 1 - pI); 
		p21th(t) = 1 - binocdf(L0r, ns, pI);
    else
        p12th(t) = 1 - binocdf(L0r, ns, 1 - pI);
		p21th(t) = binocdf(L0r, ns, pI);
    end
    
    % 3.Тестирование алгоритма методом статистических испытаний
    for kk = 1 : K % цикл по числу реализаций
        for i = 1 : M % цикл по классам
            % 3.1. Моделирование искажения
            x = s(:, i);
            r = rand(n, 1); 
			ir = find(r < pI);
            x(ir) = 1 - x(ir); % искажение элементов – инверсия в случайных точках
            x_ = 1 - x;
            
            % ЗДЕСЬ изменяется пункт с классификацией
            % 3.2. Классификация искаженного образа
            L10 = sum(x(mask10));
            P01 = sum(x_(mask01));
            u = ((L10 + P01) - L0); % вычисление значения разделяющих функций
            if pI < 0.5 
                if u>0
                    iai = 1;
                else
                    iai = 2;
                end
            else % индексы классов меняются местами
                if u>0
                    iai = 2;
                else
                    iai = 1;
                end
            end
            
            % 3.3. Фиксация результата распознавания
            Pc_(i, iai, t) = Pc_(i, iai, t) + 1; % фиксация результата распознавания
            if (kk == 1) && (t == 2) % отображение примеров искажения символов
                IAx = reshape(x_, 5, 7)'; 
                figure;
                imshow(IAx);
            end
        end
    end
    Pc_(:, :, t) = Pc_(:, :, t) / K;
    p12ex(t) = Pc_(1, 2, t);
    p21ex(t) = Pc_(2, 1, t);
end

%% 4. Визуализация результата в виде графиков вероятностей ошибок
figure;
grid on;
hold on;
ms = 1;
axis([min(pi), max(pi), 0, ms]); % установка границ поля графика по осям
p = plot(pi, p12th, '-b', pi, p21th, '-r', pi, p12ex, '--ok', pi, p21ex, '--^k');
set(p, 'LineWidth', 1.0);
title('Теоретические вероятности ошибок и их оценки', 'FontName', 'Courier', 'FontSize', 14);
xlabel('pi', 'FontName', 'Courier', 'FontSize', 14);
ylabel('P', 'FontName', 'Courier', 'FontSize', 14);
strv1 = ' pw='; 
strv2 = num2str(pw, '% G');
text(0.1, 0.75 * ms, [strv1, strv2], 'HorizontalAlignment', 'left', 'BackgroundColor',[.8 .8 .8], 'FontSize', 12);
legend('p12th ', 'p21th', 'p12ex', 'p21ex'); 
hold off;




