% Файл pr54_rec_bin. Синтез и анализ алгоритмов распознавания образов по дискретным 
% признакам (на примере распознавания бинарных изображений)

% ПРИМЕР ДЛЯ ЗАВИСИМОСТИ ОТ ЧИСЛА РАЗЛИЧАЮЩИХСЯ ПИКСЕЛЕЙ (ns)

clear all;
close all;
%% 1. Задание исходных данных
n = 35; % количество признаков (исходя из размера изображений)
M = 2;
s = zeros(n, M); % количество классов и эталонные описания
% ЗДЕСЬ МЕНЯЕТСЯ п.1.1: вместо букв генерируем случайно образ первого
% класса
% 1.1. Задание эталонов классов
img1 = randi(2, n, 1) - 1;
% 1.2. Задание параметров эксперимента
pw = [0.5, 0.5]; % априорные вероятности гипотез
np = sum(pw);
pw = pw / np; % исключение некорректного задания априорных вероятностей
N = 20;  % количество шагов изменения варьируемого параметра - pi
K = 1000; % количество реализаций
pi = zeros(1, N); % массив вероятностей искажения символа
%1.3. Массивы теор. и эксп. ошибок первого и второго рода
p12th = pi; 
p21th = pi;
p12ex = pi;
p21ex = pi;
% 1.4. Матрица ошибок
Pc_ = zeros(M, M, N); % экспериментальная матрица вероятностей ошибок

% ЗДЕСЬ добавить произвольное фиксированное значение вероятности искажения
pI = 0.25; % вероятность искажения элемента (пикселя)
pI_ = 1 - pI;

%Цикл по значениям вероятности искажения элементов символов
for t = 1 : N
    % ЗДЕСЬ убрать вычисление вероятность искажения элемента (так как оно фиксированное)
    % pi(t)=(1/N)*(t-1); pI=pi(t); %вероятность искажения элемента (пикселя)
    
    % ЗДЕСЬ добавляется генерация образа 2го класса
    % Генерация второго образа с ns различающимися элементами
    pi(t) = t / N; % ТЕПЕРЬ pi - это массив, содержащий долю различающихся пикселей в 2х классах
    ns = fix(pi(t) * n); %число отличающихся пикселей
    img2 = img1;
    img2(1 : ns) = 1 - img2(1 : ns);
    s(:, 1) = img1; 
    s(:, 2) = img2;
    s_ = 1 - s; % получение инвертированных изображений
    
    %% 2.Синтез решающего правила и расчет теоретических вероятностей ошибок
    if pI == 0
        pI = 0.0001;
    end % регуляризация разделяющей функции
    if pI == 0.5
        pI=0.4999;
    end
    pI_ = 1 - pI;
    G1 = zeros(1, n);
    G2 = zeros(1, n);    
    
	% 2.1. Вычисление порога принятия решений    
    ns = sum(abs(s(:, 1) - s(:, 2))); % общее количество несовпадающих элементов
    l0_ = log(pw(2) / pw(1)); % порог принятия решения
    L0 = log(pw(2) / pw(1)) / (2 * log(pI_) - 2 * log(pI)) + ns / 2;
    L0r = floor(L0);
    
    % 2.2.Вычисление коэффициентов разделяющей функции   
    for k = 1 : n
       G1(1, k) = log((s(k, 1) * pI_ + s_(k, 1) * pI) / (s(k, 2) * pI_ + s_(k, 2) * pI));
       G2(1, k) = log((s(k, 1) * pI + s_(k, 1) * pI_) / (s(k, 2) * pI + s_(k, 2) * pI_));
    end
    
	% 2.3. Определение вероятностей перепутывания 
    if pI < 0.5 % расчет вероятностей ошибок
        p12th(t) = binocdf(L0r, ns, 1 - pI);
        p21th(t) = 1 - binocdf(L0r, ns, pI);
    else
        p12th(t) = 1 - binocdf(L0r, ns, 1 - pI);
        p21th(t) = binocdf(L0r, ns, pI);
    end
    
    %% 3. Тестирование алгоритма методом статистических испытаний
    for kk = 1 : K % цикл по числу реализаций
        for i = 1 : M % цикл по классам
            % 3.1. Моделирование искажения
            x = s(:, i);
            r = rand(n, 1); 
			ir = find(r < pI);
            x(ir) = 1 - x(ir); % искажение элементов – инверсия в случайных точках
            x_ = 1 - x;
            
            % 3.2. Классификация искаженного образа
            u = G1 * x + G2 * x_ - l0_; % вычисление значения разделяющих функций
            if u > 0
                iai = 1;
            else
                iai = 2;
            end
            
            % 3.3. Фиксация результата распознавания
            Pc_(i, iai, t) = Pc_(i, iai, t) + 1; % фиксация результата распознавания
            if (kk == 1) && (t == 2) % отображение примеров искажения символов
                IAx = reshape(x_, 5, 7)'; 
                figure;
                imshow(IAx);
            end
        end
    end
    Pc_(:, :, t) = Pc_(:, :, t) / K;
    p12ex(t) = Pc_(1, 2, t);
    p21ex(t) = Pc_(2, 1, t);
end

%% 4. Визуализация результата в виде графиков вероятностей ошибок
figure;
grid on;
hold on;
ms = 1;
axis([min(pi), max(pi), 0, ms]); % установка границ поля графика по осям
p = plot(pi, p12th, '-b', pi, p21th, '-r', pi, p12ex, '--ok', pi, p21ex, '--^k');
set(p, 'LineWidth', 1.0);
title( 'Теоретические вероятности ошибок и их оценки', 'FontName', 'Courier', 'FontSize', 14);
xlabel('pi', 'FontName', 'Courier', 'FontSize', 14);
ylabel('P', 'FontName', 'Courier', 'FontSize', 14);
strv1 = ' pw='; 
strv2 = num2str(pw, '% G');
text(0.1, 0.75 * ms, [strv1, strv2], 'HorizontalAlignment', 'left', 'BackgroundColor', [.8 .8 .8], 'FontSize', 12);
legend('p12th ', 'p21th', 'p12ex', 'p21ex'); 
hold off;