%Функция для отображения функции ядра и получения оценки 
%плотности распределения вероятностей методом Парзена
function p_=vkernel(x,XN,h_N,kl_kernel)
%x-массив векторов (точек), для которых определяется плотность
%XN-входная обучающая выборка данных
%h_N- параметр, определяющий размер области локализации ядра (оконной функции)
%kl_kernel-ключ для определения вида используемого ядра
%kl_kernel=11 - гауссовская функция c использованием диагональной матрицы;
%kl_kernel=12 - гауссовская функция c использованием матрицы ковариации;
%kl_kernel=2 - показательная функция;    
%kl_kernel=3 - оконная прямоугольная функция;
%kl_kernel=4 - оконная треугольная функция; 
[n1,mx]=size(x);%размерность пространства и число точек, для которых проводится оценка
[n2,N]=size(XN);%размерность пространства и число СВ в обучающей выборке 
if n1==n2, n=n1;
    p_=zeros(1,mx); C=eye(n,n); C_=C;
    if kl_kernel==12 && N>1, %оценка выборочной матрицы ковариации выборки
        C=zeros(n,n); m_=mean(XN')';
        for i=1:N,
             C=C+(XN(:,i)-m_)*(XN(:,i)-m_)';
        end;
        C=C/(N-1); C_=C^-1;
    end;
    %Вычисление значений N функций ядра с центрами XN(:,1:N) в точках x(:,1:mx)
    %При N=1 получаем единичную функцию ядра c с центром XN(:,1)
    fit=zeros(N,mx); 
    for i=1:N,
        p_k=zeros(n,mx); mx_i=repmat(XN(:,i),[1,mx]);
        switch kl_kernel,
            case 11,
                ro=sum((x-mx_i).^2,1); 
                fit(i,:)=exp(-ro/(2*h_N^2))/((2*pi)^(n/2)*(h_N^n));
            case 12,
                ro=sum((C_*(x-mx_i)).*(x-mx_i),1);
                fit(i,:)=exp(-ro/(2*h_N^2))*((2*pi)^(-n/2)*(h_N^-n)*(det(C)^-0.5));
            case 2,
                ro=abs(x-mx_i)/h_N; 
                fit(i,:)=prod(exp(-ro),1)/(2*h_N^n); 
            case 3,
                ro=abs(x-mx_i)/h_N; 
                for k=1:n, 
                    ind=find(ro(k,:)<1); p_k(k,ind)=1/2;
                end;
                fit(i,:)=prod(p_k,1)/h_N^n;
            case 4,
                ro=abs(x-mx_i)/h_N; 
                for k=1:n, 
                   ind=find(ro(k,:)<1); p_k(k,ind)=(1-ro(k,ind));
                end;
                fit(i,:)=prod(p_k,1)/h_N^n; 
        end; %kl_kernel
    end;%i=1:N
    %Вычисление оценки плотности распределения вероятностей
    if N>1, p_=sum(fit)/N; else p_=fit; end;
else %n1=~n2
    error('размерности данных (n1 и n2) не совпадают');
end;
